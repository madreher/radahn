from flask import Flask, render_template 
import logging
import threading
from threading import Lock
import zmq
from flask_socketio import SocketIO
import uuid
from pathlib import Path
import os
import numpy as np

from ase.io import write, read
from ase.atoms import Atoms

app = Flask(__name__)
app.config['SECRET_KEY'] = 'secret!'
app.logger.setLevel(logging.INFO)
socketio = SocketIO(app)
#app = None
#socketio = None

thread = None
thread_lock = Lock()
threadAtoms = None
thread_lockAtoms = Lock()
threadGenerateInputs = None
thread_lockGenerateInputs = Lock()

rootJobFolder = Path(os.getenv("HOME") + "/.radahn/jobs")

@app.route('/')
def index():
    return render_template('index.html')

def getElementsFromData(dataPath: str) -> str:
    """Get elements from data file

    Args:
        data_file: LAMMPS data file

    Returns:
        elements: LAMMPS atom types

    """
    with open(dataPath, 'r') as f:
        lines = f.readlines()
    i = 0
    for line in lines:
        if line[:6] == 'Masses':
            ini = i + 2
        if line[:5] == 'Atoms':
            fin = i - 1
        i += 1
    elements = ''
    for line in lines[ini:fin]:
        elements += ' ' + line.split()[-1]
    return elements

def xyzToLammpsDataPBC(xyzPath:str, dataPath:str) -> Atoms:
    """Convert xyz to LAMMPS data

    Args:
        xyz_file: XYZ file

    Returns:
        data_file: LAMMPS data file

    """
    atoms = read(xyzPath)

    if atoms.get_cell().max() == 0:
        if os.path.isfile('cell.txt'):
            cell = np.loadtxt('cell.txt')
        else:
            cell = [500, 500, 500]
        atoms.set_cell([cell[0], cell[1], cell[2]])
    if atoms.get_positions().min() < 0:
        atoms.center()
    write(filename=dataPath, images=atoms, format='lammps-data', atom_style='full')

    chemical_symbols = atoms.get_chemical_symbols()
    masses = atoms.get_masses()
    indexes = np.unique(chemical_symbols, return_index=True)[1]
    masses_u = [masses[index] for index in indexes]
    chemical_symbols_u = [chemical_symbols[index] for index in indexes]

    with open(dataPath, 'r') as f:
        lines = f.readlines()

    with open(dataPath, 'w') as f:
        f.write('# Generated by Radahn\n')
        for i in range(2,7):
            f.write(lines[i])
        f.write('\n')
        f.write('Masses\n')
        f.write('\n')
        for i in range(len(masses_u)):
            f.write(f'{i + 1} {masses_u[i]} # {chemical_symbols_u[i]}\n')
        f.write('\n')
        f.write('Atoms # full\n')
        f.write('\n')
        for i in range(11, len(lines)):
            f.write(lines[i])
    
    return atoms

def generate_inputs(xyz:str, ffContent:str, ffFileName:str):

    # Create the job folder 
    jobID = uuid.uuid4()
    jobFolder = rootJobFolder / str(jobID)
    os.makedirs(jobFolder)

    # Create the necessary inputs files 
    xyzFile = jobFolder / "input.xyz"
    with open(xyzFile, "w") as f:
        f.write(xyz)
        f.close()

    ffFile = jobFolder / ffFileName
    with open(ffFile, "w") as f:
        f.write(ffContent)
        f.close()


    dataFile = jobFolder / "input.data"

    # Generate the base Lammps script
    lammpsScriptFile = jobFolder / "input.lammps"
    useAcks2 = True
    with open(lammpsScriptFile, "w") as f:
        # Convert the XYZ to a .data file 
        atoms = xyzToLammpsDataPBC(xyzFile, dataFile)

        # Extract the simulation box
        cell = atoms.get_cell()
        minCellDim = min([cell[0][0], cell[1][1], cell[2][2]])
        #print(f"Minimum cell dimension: {minCellDim}")

        # Get back the list of elements
        elements = getElementsFromData(dataFile)

        scriptContent = "# -*- mode: lammps -*-\n"
        scriptContent += 'units          real\n'
        scriptContent += 'atom_style     full\n'
        scriptContent += 'atom_modify    map hash\n'
        scriptContent += 'newton         on\n'
        scriptContent += 'boundary       p p p\n'

        scriptContent += 'read_data      input.data\n'
        #for i in range(len(indexes)):
        #    scriptContent += f'mass           {i + 1} {masses_u[i]}\n' 
        scriptContent += 'pair_style     reaxff NULL mincap 1000\n'
        scriptContent += f'pair_coeff     * * {ffFileName}{elements}\n'
        if useAcks2:
            scriptContent += 'fix            ReaxFFSpec all acks2/reaxff 1 0.0 10.0 1e-8 reaxff\n'
        else:
            scriptContent += 'fix            ReaxFFSpec all qeq/reaxff 1 0.0 10.0 1e-8 reaxff\n'
        #scriptContent += 'neighbor       2.5 bin\n' 
        # 2.5 is too large for small molecule like benzene. Trying to compute a reasonable cell skin based on the simulation box
        scriptContent += f"neighbor       {min([2.5, minCellDim/2])} bin\n"
        scriptContent += 'neigh_modify   every 1 delay 0 check yes\n'


        # Add basic IO setup
        scriptContent += """####

thermo         50
thermo_style   custom step etotal pe ke temp press pxx pyy pzz lx ly lz
thermo_modify  flush yes lost warn

dump           dump all custom 100 fulltrajectory.dump id type x y z q
dump_modify    dump sort id
dump           xyz all xyz 100 fulltrajectory.xyz
dump_modify    xyz sort id element C H
fix            fixbond all reaxff/bonds 100 bonds_reax.txt

####

timestep       0.5"""
        scriptContent += "\n\n"


        f.write(scriptContent)

    # Generate the data file
    dataFile = jobFolder / "input.data"
    xyzToLammpsDataPBC(xyzFile, dataFile)

    return 


def listen_to_zmq_socket():
    context = zmq.Context()
    socket = context.socket(zmq.SUB)
    socket.connect("tcp://localhost:50000")
    socket.setsockopt(zmq.SUBSCRIBE, b"")
    app.logger.info("Listening for ZMQ messages on tcp://localhost:50000")
    while True:
        message = socket.recv()
        #app.logger.info("Received a message from ZMQ on python side: %s", message)
        socketio.emit('zmq_message', {'message': message.decode('utf-8')})
        #time.sleep(1)  # wait for 1 second before receiving the next message

def listen_to_zmq_socketAtoms():
    context = zmq.Context()
    socket = context.socket(zmq.SUB)
    socket.connect("tcp://localhost:50001")
    socket.setsockopt(zmq.SUBSCRIBE, b"")
    app.logger.info("Listening for ZMQ messages on tcp://localhost:50001")
    while True:
        message = socket.recv()
        #app.logger.info("Received a message from ZMQ on python side: %s", message)
        socketio.emit('zmq_message_atoms', {'message': message.decode('utf-8')})
        #time.sleep(1)  # wait for 1 second before receiving the next message

# Receive the test request from client and send back a test response
@socketio.on('start_listening')
def handle_start_listening():
    app.logger.info("Received a request to start listening to the simulation.")
    global thread
    with thread_lock:
        if thread is None:
            thread = socketio.start_background_task(listen_to_zmq_socket)
            app.logger.info("Background thread listening for KVS started.")
        else:
            app.logger.info("Background task listening to KVS already started.")

    global threadAtoms
    with thread_lockAtoms:
        if threadAtoms is None:
            threadAtoms = socketio.start_background_task(listen_to_zmq_socketAtoms)
            app.logger.info("Background thread listening for atoms started.")
        else:
            app.logger.info("Background task listening to atoms already started.")
    #emit('test_response', {'data': 'Test response sent'})

@socketio.on('generate_inputs')
def handle_generate_inputs(data):
    app.logger.info("Received a request to generate inputs.")
    global threadGenerateInputs
    with thread_lockGenerateInputs:
        if threadGenerateInputs is None:
            threadGenerateInputs = socketio.start_background_task(generate_inputs, data['xyz'], data['ff'], data['ffName'])
            app.logger.info("Background thread generating inputs started.")
        else:
            app.logger.info("Background task generating inputs already started.")
    

#def run_zmq_thread():
#    thread = threading.Thread(target=listen_to_zmq_socket)
#    thread.daemon = True
#    thread.start()



if __name__ == '__main__':
    #app = Flask(__name__)
    #app.config['SECRET_KEY'] = 'secret!'
    #socketio = SocketIO(app)
    #run_zmq_thread()
    socketio.run(app, host='localhost', port=5000)