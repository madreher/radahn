<!DOCTYPE html>
<html>
<head>
    <title>Radahn Mega Frontend</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/3.0.4/socket.io.js" integrity="sha512-aMGMvNYu8Ue4G+fHa359jcPb1u+ytAF+P2SCb+PxrjCdO3n3ZTxJ30zuH39rimUggmTwmh2u7wvQsDTHESnmfQ==" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/hammer.js/2.0.8/hammer.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chartjs-plugin-zoom/1.1.1/chartjs-plugin-zoom.min.js"></script>
    <script src="https://3Dmol.org/build/3Dmol-min.js"></script>   
    <link href="/static/css/external/litegraph.css" rel="stylesheet">     
    <script src="/static/js/external/litegraph.min.js"></script>
    <script src="/static/js/console_redirect.js"></script>
    <script src="/static/js/radahn_graph.js"></script>
    <script src="/static/js/project_utils.js"></script>
</head>
<body>
    <script type="text/javascript" charset="utf-8">
    $(document).ready(function() {

        // TODOs:
        // - Add support for multiple molecules
        // - Clear the molecule, selection table, and plots when a new molecule is loaded


        // Global variables

        //SocketIO
        var socket = io();

        var project = new RadahnProject();

        // 3Dmol
        var elementMolecule = document.getElementById('visualization');
        var elementMoleculeOverlay = document.getElementById('visualization-overlay');
        var overlayContext = elementMoleculeOverlay.getContext('2d');
        
        var configMolecule = {
            backgroundColor: 'black',
            nomouse: true
        } 
        var viewerMolecule = $3Dmol.createViewer(elementMolecule, configMolecule);
        var originalPositions = null; // Copy of the positions loaded from file.
        var timestepFrames = [0];
        var intervalUpdateID = null;


        // Selection drawing tracking
        var isDrawing = false;
        var startPoint = null;
        var dx = null;
        var dy = null;
        var startPointOverlay = null;
        var dxOverlay = null;
        var dyOverlay = null;
        var mapObjectsToScreen = null;

        // Selection table
        var selectedAtoms = [];
        currentLabelsType = "none";
        var currentLabels = [];
        updateDynamicTable();

        // Anchor table
        updateAnchorTable();

        // Thermostats table
        updateThermostatTable();

        // Node Editor
        var nodeEditor = new LGraph();
        var nodeEditorCanvas = new LGraphCanvas("#node-canvas", nodeEditor);
        radahnGraphUtil.setupRadahnGraph(nodeEditor);
        nodeEditor.start();
        nodeEditorCanvas.resize();

        // KVS temporal data
        var kvsData = {};
        var listKVSFields = [];
        var firstPlotKey = null;
        var secondPlotKey = null;

        // Miscalaneous
        var allInputs = document.querySelectorAll('input');
        allInputs.forEach(input => {
            if (input.type == 'text') {
                input.value = '';
            }
        });

        // Defining custom listener when needed, forwarding to 3dmol.js otherwise

        // Event listener for mouse down (left click + Shift key)
        viewerMolecule.container.addEventListener('mousedown', (event) => {
            if (event.button === 0 && event.shiftKey) {
                startPoint = { x: event.clientX, y: event.clientY };

                console.log("Start point for selection:", startPoint);
                if(viewerMolecule.getModel() != null)
                {
                    isDrawing = true;
                    mapObjectsToScreen = viewerMolecule.modelToScreen(viewerMolecule.getModel().getInternalState().atoms);
                    console.log("mapObjectsToScreen:", mapObjectsToScreen);
                    selectedAtoms = [];

                    // Clear the current selection
                    document.getElementById('current-selection').value = "";
                    refreshMolecule();
                }
                else 
                {
                    console.log("Model is empty, selection not tracked");
                }
            }
            else {
                //console.log("Left button detected but not intercepted. Foward to 3Dmol.js");
                viewerMolecule._handleMouseDown(event);
            }
        });

        // Event listener for mouse move
        viewerMolecule.container.addEventListener('mousemove', (event) => {
            if (isDrawing) {
                // Calculate distance between current point and start point
                dx = event.clientX - startPoint.x;
                dy = event.clientY - startPoint.y;

                overlayContext.beginPath();
                //overlayContext.fillStyle = 'rgba(255, 0, 0, 0.5)';
                //overlayContext.fillRect(startPoint.x, startPoint.y, dx, dy);
                let rect3DMol = elementMolecule.getBoundingClientRect();
                overlayContext.strokeStyle = 'rgba(255, 0, 0, 0.5)';
                overlayContext.rect(startPoint.x, startPoint.y, dx, dy);
                overlayContext.stroke();

                //console.log("dx:", dx, "dy:", dy);
                //console.log("Rect 3Dmol:", rect3DMol);

            }
            else 
            {
                //console.log("Mouse move detected but not intercepted. Foward to 3Dmol.js");
                viewerMolecule._handleMouseMove(event);
            }
        });

        // Event listener for mouse up
        viewerMolecule.container.addEventListener('mouseup', () => {
            if (isDrawing) {
                isDrawing = false;
                

                console.log(`Stopping drawing, will do the selection at this point within the rectangle. Looking for atoms between (${startPoint.x}, ${startPoint.y}) and (${startPoint.x + dx}, ${startPoint.y + dy})`);
                for(let i = 0; i < mapObjectsToScreen.length; i++)
                {
                    if(mapObjectsToScreen[i].x >= startPoint.x && mapObjectsToScreen[i].x <= startPoint.x + dx && mapObjectsToScreen[i].y >= startPoint.y && mapObjectsToScreen[i].y <= startPoint.y + dy)
                    {
                        selectedAtoms.push(i);
                    }
                }
                console.log("Selected atoms:", selectedAtoms);
                viewerMolecule.getModel().setStyle({'serial': selectedAtoms}, {'stick': {'color': 'yellow'}});
                viewerMolecule.render();

                // Updating the current selection field
                $('#current-selection').empty();
                if(selectedAtoms.length > 0)
                {
                    let strSelection = "";
                    for(let i = 0; i < selectedAtoms.length; i++)
                    {
                        strSelection += selectedAtoms[i] + " ";
                    }
                    document.getElementById('current-selection').value = strSelection;
                    console.log("Current selection:", strSelection);
                }
                
                startPoint = null;
            }
            else 
            {
                //console.log("Mouse up detected but not intercepted. Foward to 3Dmol.js");
                viewerMolecule._handleMouseUp(event);
            }
        });

        viewerMolecule.container.addEventListener('mousewheel', (event) => {
                //console.log("Mouse wheel detected but not intercepted. Foward to 3Dmol.js");
                viewerMolecule._handleMouseScroll(event);
        });

        viewerMolecule.container.addEventListener('DOMMouseScroll', (event) => {
                //console.log("DOM Mouse wheel detected but not intercepted. Foward to 3Dmol.js");
                viewerMolecule._handleMouseScroll(event);
        });

        // Forward events from the overlay to the molecule canvas
        elementMoleculeOverlay.addEventListener('mousedown', (event) => {
            viewerMolecule.container.dispatchEvent(new MouseEvent('mousedown', event)); // Forward to 3Dmol.js (not the molecule canvas) for selection event);
            if (event.button === 0 && event.shiftKey) {
                startPointOverlay = { x: event.clientX, y: event.clientY };
            }
        });
        elementMoleculeOverlay.addEventListener('mousemove', (event) => {
            viewerMolecule.container.dispatchEvent(new MouseEvent('mousemove', event));
            if(isDrawing)
            {
                // Get the rectangle of the canvas
                let rectOverlay = elementMoleculeOverlay.getBoundingClientRect();

                // Calculate the scale factor between the canvas and the bitmap
                let scaleX = elementMoleculeOverlay.width / rectOverlay.width;
                let scaleY = elementMoleculeOverlay.height /rectOverlay.height;
                dxOverlay = (event.clientX - startPointOverlay.x) * scaleX;
                dyOverlay = (event.clientY - startPointOverlay.y) * scaleY;

                // Substract the top left corner of the canvas from the startPoint
                let newStartPoint = {
                    x: (startPointOverlay.x - rectOverlay.left) * scaleX,
                    y: (startPointOverlay.y - rectOverlay.top) * scaleY
                }

                //overlayContext.fillStyle = 'rgba(255, 0, 0, 0.1)';
                //overlayContext.fillRect(newStartPoint.x, newStartPoint.y, dxOverlay, dyOverlay);
                overlayContext.clearRect(0, 0, elementMoleculeOverlay.width, elementMoleculeOverlay.height);
                overlayContext.beginPath();
                overlayContext.strokeStyle = 'rgba(255, 0, 0, 1.0)';
                overlayContext.rect(newStartPoint.x, newStartPoint.y, dxOverlay, dyOverlay);
                overlayContext.stroke();
                
                //console.log("Rect overlay: ", rectOverlay, "scaleX:", scaleX, "scaleY:", scaleY);
            }
        });
        elementMoleculeOverlay.addEventListener('mouseup', (event) => {
            viewerMolecule.container.dispatchEvent(new MouseEvent('mouseup', event));
            if(!isDrawing)
            {
                // Clear the overlay
                overlayContext.clearRect(0, 0, elementMoleculeOverlay.width, elementMoleculeOverlay.height);
            }
        });
        elementMoleculeOverlay.addEventListener('mousewheel', (event) => {
            viewerMolecule.container.dispatchEvent(new MouseEvent('mousewheel', event));
        });
        elementMoleculeOverlay.addEventListener('DOMMouseScroll', (event) => {
            viewerMolecule.container.dispatchEvent(new MouseEvent('DOMMouseScroll', event));
        })

        // Handle file selection
        const inputProject = document.getElementById('project-file');
        inputProject.addEventListener('change', handleProjectFileSelect, false)

        const input = document.getElementById('xyz-file');
        input.addEventListener('change', handleFileSelect, false);

        const inputFF = document.getElementById('ff-file');
        inputFF.addEventListener('change', handleForcefieldFileSelect, false);

        // Get the canvas element
        const canvas = document.getElementById('plot-canvas');
        const canvaTemp = document.getElementById('plot-canvas-temp');

        // Create a Chart.js instance
        const chart1 = new Chart(canvas, {
        type: 'line',
        data: {
            datasets: [{
            label: 'Undefined',
            data: [],
            borderColor: 'rgba(75, 192, 192, 1)',
            borderWidth: 2,
            fill: false
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                tooltip: {
                    usePointStyle: true,
                },
                zoom: {
                    zoom: {
                        wheel: {
                            enabled: true,
                        },
                        pinch: {
                            enabled: true
                        },
                        mode: 'x',
                    },
                    pan: {
                        enabled: true,
                        mode: 'x',
                    }/*,
                    limits: {
                        x: {
                            minRange: 3
                        },
                    },*/
                }
            }
        }
        });
        const chart2 = new Chart(canvaTemp, {
        type: 'line',
        data: {
            datasets: [{
            label: 'Undefined',
            data: [],
            borderColor: 'rgba(75, 192, 192, 1)',
            borderWidth: 2,
            fill: false
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                tooltip: {
                    usePointStyle: true,
                },
                zoom: {
                    zoom: {
                        wheel: {
                            enabled: true,
                        },
                        pinch: {
                            enabled: true
                        },
                        mode: 'x',
                    },
                    pan: {
                        enabled: true,
                        mode: 'x',
                    }/*,
                    limits: {
                        x: {
                            minRange: 3
                        },
                    },*/
                }
            }
        }
        });

        socket.on('zmq_message', function(data) {
            let msg = JSON.parse(data.message);
            //console.log('Received ZMQ message on JS side:', data.message);


            if (!('global' in msg)) {
                console.log('The "global" key is not present in the msg');
                return;
            }

            // Find all fields
            
            function extractKeysAndValues(obj, parentKey = "") {
                let result = [];
                for (let key in obj) {
                    if (obj.hasOwnProperty(key)) {
                        let newKey = parentKey ? parentKey + "." + key : key;
                        if (typeof obj[key] !== "object" || obj[key] === null) {
                            result.push({key: newKey, value: obj[key]});
                        }
                        else {
                            result = result.concat(extractKeysAndValues(obj[key], newKey));
                        }
                    }
                }
                return result;
            }
            
            //let keys = extractKeys(msg);
            let fields = extractKeysAndValues(msg);
            //console.log(fields);

            // Updating the internal map
            let simIt = msg['global']['simIt'];
            for (let i = 0; i < fields.length; i++) {
                if(fields[i].key in kvsData) {
                    // The keys is already in the object, appending the data to the same key
                    kvsData[fields[i].key].it.push(simIt);
                    kvsData[fields[i].key].values.push(fields[i].value);

                    // Updating the plots if necessary
                    if(firstPlotKey === fields[i].key) {
                        chart1.update();
                    }

                    if(secondPlotKey === fields[i].key) {
                        chart2.update();
                    }
                }
                else {
                    // The keys is not in the object, creating a new key
                    kvsData[fields[i].key] = {
                        it: [simIt],
                        values: [fields[i].value]
                    };

                    listKVSFields.push(fields[i].key);

                    // Updating the UI
                    let selectionPlot1 = document.getElementById('select-plot1');
                    selectionPlot1.options.length = 0;
                    for(let i = 0; i < listKVSFields.length; i++) {
                        let opt = listKVSFields[i];
                        let el = document.createElement("option");
                        el.textContent = opt;
                        el.value = opt;
                        selectionPlot1.appendChild(el);
                    }
                    let selectionPlot2 = document.getElementById('select-plot2');
                    selectionPlot2.options.length = 0;
                    for(let i = 0; i < listKVSFields.length; i++) {
                        let opt = listKVSFields[i];
                        let el = document.createElement("option");
                        el.textContent = opt;
                        el.value = opt;
                        selectionPlot2.appendChild(el);
                    }
                }
            }
        
        });

        socket.on('zmq_message_atoms', function(data) {
            let msg = JSON.parse(data.message);
            //console.log('Received Atoms message on JS side:', msg);
            
            if (!('positions' in msg)) {
                console.log('The "positions" key is not present in the msg');
                return;
            }

            
            // Update the positions of the atoms in the viewer
            let positions = msg['positions'];

            // Create a new Frame and add it to the viewer
            let newFrame = structuredClone(originalState.atoms); // Copy all the atom attributes, just need to update with new positions

            let nbAtomsModel = originalState.atoms.length;

            let atomCount = positions.length / 3;
            for(let i = 0; i < atomCount; i++) {
                newFrame[i].x = positions[i * 3];
                newFrame[i].y = positions[i * 3 + 1];
                newFrame[i].z = positions[i * 3 + 2];
            }
            viewerMolecule.getModel().addFrame(newFrame);
            //viewerMolecule.animate({loop: "forward", reps:1});
            viewerMolecule.setFrame(viewerMolecule.getModel().getNumFrames()-1);

            timestepFrames.push(msg['simIt']);
            if(nbAtomsModel != atomCount)
            {
                console.error("Inconsitent number of atoms received. Expected " + nbAtomsModel + ", received " + atomCount +".");
                console.log(msg['simIt'] + ":");
                console.log(positions);
            }
            
            $('#info-sim-it').empty();
            $('#info-sim-it').append('Current Timestep: ' + msg['simIt'] + ', Current Frame: ' + (viewerMolecule.getModel().getNumFrames()-1) + ', number of Frames: ' + viewerMolecule.getModel().getNumFrames());
            //viewerMolecule.render();
            refreshMolecule();
            
            
        });

        socket.on('job_folder', function(data) {
            console.log('Job folder information received:', data.message);
            document.getElementById('job_folder').value = data.message;
        });

        socket.on('log_message', function(data) {
            console[data['level']](data['msg']);
        })

        document.getElementById('project-name').addEventListener('input', function(e){
            if(this.checkValidity())
            {
                project.projectName = this.value;
            }
            else 
            {
                this.value = project.projectName;
            }
        })

        window.refreshNVTSetup = function(){
            let enableCreateVelocity = document.getElementById("createvel").checked;
            let enableNVTPhase = document.getElementById("nvtphase").checked;
            if(enableCreateVelocity)
            {
                project.declareNVTCreateVelocity(
                    parseFloat(document.getElementById("create_vel_temp").value),
                    parseFloat(document.getElementById("create_vel_seed").value)
                )
            }
            else if(enableNVTPhase)
            {
                project.declareNVTPhase(
                    parseFloat(document.getElementById("startTemp").value),
                    parseFloat(document.getElementById("endTemp").value),
                    parseFloat(document.getElementById("damp").value),
                    parseInt(document.getElementById("seed").value),
                    parseInt(document.getElementById("nvtsteps").value)
                )
            }
            else
            {
                project.clearNVT();
            }
        }

        window.refreshMinimizeSetup = function(){
            let enableMinimize = document.getElementById("minimization").checked;
            let enableDeepMinimize = document.getElementById("deep_minimization").checked;

            if(enableMinimize)
            {
                project.declareMinimize();
            }
            else if(enableDeepMinimize)
            {
                project.declareDeepMinimize();
            }
            else 
            {
                project.clearMinimize();
            }
        }

        window.generate_inputs = function() {

            console.log("Requesting to generate Lammps input files in a job folder.");

            // Check which model to use for the simulation
            let xyzSetup = document.getElementById("start_from").value;
            let xyzData = "";

            if(xyzSetup == "original"){
                //xyzData = xyzContent;    
                xyzData = project.xyzContent;
                console.log("Generating inputs from the original molecule.")
            }
            else if(xyzSetup == "current-frame"){
                xyzData = radahnProjectUtils.viewerToXYZ(viewerMolecule, viewerMolecule.getFrame());
                console.log("Generating inputs from the frame: " + viewerMolecule.getFrame());
            }

            if(xyzData.length == 0){
                console.error("No molecule was loaded. Please load a molecule before generating inputs. ");
                return false;
            }

            if(project.potentialContent.length == 0){
                console.error("No forcefield was loaded. Please load a forcefield before generating inputs. ");
                return false;
            }

            // Get the settings from the editor
            let motorUnitSet = document.getElementById("unit_set").value;
            let simDt = parseFloat(document.getElementById("dt_input").value);
            if(!radahnGraphUtil.checkValid(nodeEditor))
            {
                console.error("Motor graph is not valid, unable to generate input files.");
                return false;
            }
            let radahnJSONContent = radahnGraphUtil.generateMotorsJSON(nodeEditor, project.selectionList, motorUnitSet);
            let numberCores = document.getElementById("num_cores").value;
            let maxTimestep = document.getElementById("num_timesteps").value;
            let forceTimestep = document.getElementById("force_max_steps").checked;
            let updateFrequency = document.getElementById("update_frequency").value;
            refreshMinimizeSetup();
            refreshNVTSetup();
            let lammpsJSONContent = project.generateLammpsConfigJSON(motorUnitSet);

            let configDict = {  }

            configDict['number_cores'] = numberCores;
            configDict['max_timestep'] = maxTimestep;
            configDict['force_timestep'] = forceTimestep;
            configDict['update_frequency'] = updateFrequency;
            configDict['motors'] = radahnJSONContent;
            configDict['xyz'] = xyzData;
            configDict['ffContent'] = project.potentialContent;
            configDict['ffName'] = project.potentialFilename;
            configDict['lmp_config'] = lammpsJSONContent;
            configDict['unit_set'] = motorUnitSet;
            configDict["dt"] = simDt;
            if(project.minimizeEnabled)
                configDict['minimize_config'] = project.minimizeConfig;

            socket.emit('generate_inputs', configDict);
            return false;
        };

        window.launch_simulation = function() {
            console.log('Requesting to launch simulation.');

            // Check which model to use for the simulation
            let xyzSetup = document.getElementById("start_from").value;
            let xyzData = "";
            let viewerFrameReset = -1; // original frame from the loaded xyz

            if(xyzSetup == "original"){
                //xyzData = xyzContent;    
                xyzData = project.xyzContent;
                console.log("Generating inputs from the original molecule.")
            }
            else if(xyzSetup == "current-frame"){
                xyzData = radahnProjectUtils.viewerToXYZ(viewerMolecule, viewerMolecule.getFrame());
                console.log("Generating inputs from the frame: " + viewerMolecule.getFrame());
                viewerFrameReset = viewerMolecule.getFrame();
            }

            if(xyzData.length == 0){
                console.error("No molecule was loaded. Please load a molecule before generating inputs. ");
                return false;
            }

            if(project.potentialContent.length == 0){
                console.error("No forcefield was loaded. Please load a forcefield before generating inputs. ");
                return false;
            }

            // Get the settings from the editor
            let motorUnitSet = document.getElementById("unit_set").value;
            let simDt = parseFloat(document.getElementById("dt_input").value);
            if(!radahnGraphUtil.checkValid(nodeEditor))
            {
                console.error("Motor graph is not valid, unable to generate input files.");
                return false;
            }
            let radahnJSONContent = radahnGraphUtil.generateMotorsJSON(nodeEditor, project.selectionList, motorUnitSet);
            let numberCores = document.getElementById("num_cores").value;
            let maxTimestep = document.getElementById("num_timesteps").value;
            let forceTimestep = document.getElementById("force_max_steps").checked;
            let updateFrequency = document.getElementById("update_frequency").value;
            refreshMinimizeSetup();
            refreshNVTSetup();
            let lammpsJSONContent = project.generateLammpsConfigJSON(motorUnitSet);
            let configDict = {  };


            if(radahnJSONContent.length == 0 && !forceTimestep){
                console.warn("No motors were declared and the option 'Force max step' is not set. Enabling the option automatically.");
                forceTimestep = true;
            }

            if(numberCores < 1){
                console.warn("The number of cores must be greater than 0. Switching the number of cores to 1.");
                numberCores = 1;
            }
            if(updateFrequency < 1){
                console.warn("The update frequency must be greater than 0. Switching the update frequency to 100.");                
                updateFrequency = 100;
            }

            // At this point, the settings have been checked and ready to be sent to the server
            // We can clear the current state of the temporal data
            

            resetTemporalData(viewerFrameReset);

            configDict['number_cores'] = numberCores;
            configDict['max_timestep'] = maxTimestep;
            configDict['force_timestep'] = forceTimestep;
            configDict['update_frequency'] = updateFrequency;
            configDict['motors'] = radahnJSONContent;
            configDict['xyz'] = xyzData;
            configDict['ffContent'] = project.potentialContent;
            configDict['ffName'] = project.potentialFilename;
            configDict['lmp_config'] = lammpsJSONContent;
            configDict['unit_set'] = motorUnitSet;
            configDict["dt"] = simDt;
            if(project.minimizeEnabled)
                configDict['minimize_config'] = project.minimizeConfig;

            socket.emit('launch_simulation', configDict);
            return false;
        };

        $('form#print_motors').submit(function(event) {
            let radahnJSONContent = radahnGraphUtil.generateJSON(nodeEditor, project.selectionList);
            console.log(radahnJSONContent);
            return false;
        });

        window.open_job_folder = function() {
            jobFolder = document.getElementById("job_folder").value;
            if(jobFolder.length == 0){
                console.error("No job folder was specified. Please specify a job folder. ");
                return false;
            }
            console.log("Requesting to open job folder: " + jobFolder);
            socket.emit('open_job_folder', {'jobFolder': jobFolder});
            return false;
        };

        function resetTemporalData(frameIndex = -1) {
            // Reset the plots 
            kvsData = {};
            listKVSFields = [];
            firstPlotKey = null;
            secondPlotKey = null;
            chart1.data.label = 'Undefined';
            chart1.data.datasets[0].data = [];
            chart1.update();
            let selectionPlot1 = document.getElementById('select-plot1');
            selectionPlot1.options.length = 0;
            chart2.data.label = 'Undefined';
            chart2.data.datasets[0].data = [];
            chart2.update();
            let selectionPlot2 = document.getElementById('select-plot2');
            selectionPlot2.options.length = 0;


            // Reset the molecule viewer trajectory
            if(frameIndex < 0)
            {
                console.log("Resetting the viewer with the original state.");
                viewerMolecule.getModel().setInternalState(originalState);
                // Copy may not be necessary, I'm not sure if the setCoordinates makes a copy internally or use a pointer.
                viewerMolecule.getModel().setCoordinates(structuredClone(originalPositions), "array")
            }
            else
            {
                // We are going to move the frame frameIndex to the index 0 and remove the rest. 

                // Save the positions of the frame to save 
                let lookupFrame = frameIndex;
                if(lookupFrame >= viewerMolecule.getModel().getNumFrames())
                {
                    console.log("Frame index is out of bounds when reseting the viewer. Using the last frame instead.");
                    lookupFrame = viewerMolecule.getModel().getNumFrames() - 1;
                }
                else 
                {
                    console.log("Resetting the viewer with the frame: " + lookupFrame);
                }

                let temporalPositions = radahnProjectUtils.viewerToArray(viewerMolecule, lookupFrame);

                // Now that we have saved the data we needed, we can restore the initial state
                viewerMolecule.getModel().setInternalState(originalState);

                // Update the positions of the initial state.
                viewerMolecule.getModel().setCoordinates(temporalPositions, "array");
            }
            
            viewerMolecule.zoomTo();
            viewerMolecule.animate({loop: "forward", reps:1});
            viewerMolecule.render();
            timestepFrames = [0];

            $('#info-sim-it').empty();
            $('#info-sim-it').append('Current Timestep: 0, number of Frames: ' + viewerMolecule.getModel().getNumFrames());
        }

        function handleProjectFileSelect(evt) 
        {
            console.log("Project File selected: " + evt.target.files[0].name);
            const file = evt.target.files[0];

            if (file) {
                const reader = new FileReader();

                reader.onload = function(event) 
                {
                    const content = event.target.result;
                    const obj = JSON.parse(content);
                    project.loadFromProjectDict(obj);

                    // Update the different widgets
                    // Viewer
                    if(project.isXYZSet())
                    {
                        viewerMolecule.addModel(project.xyzContent, 'xyz');
                        viewerMolecule.setStyle({}, {stick: {}})
                        viewerMolecule.zoomTo();
                        viewerMolecule.render();
                        console.info("Loaded a model from XYZ file with " + viewerMolecule.getModel().getInternalState().atoms.length + " atoms.");

                        $('#info-sim-it').empty();
                        $('#info-sim-it').append('Current Timestep: 0, number of Frames: ' + viewerMolecule.getModel().getNumFrames());

                        // Saving the first frame 
                        // Saving both the positions and original state separatly because the state does contain all the atom informations
                        // which is used in some places 
                        originalState = structuredClone(viewerMolecule.getModel().getInternalState());
                        originalPositions = radahnProjectUtils.viewerToArray(viewerMolecule, 0);
                        
                        // Text fields
                        document.getElementById('project-name').value = project.projectName;

                        // Selection,anchor, thermostats table
                        updateDynamicTable();
                        updateAnchorTable();
                        updateThermostatTable();

                        // Node graph
                        if(project.hasMotorGraph())
                        {
                            // Source: https://github.com/jagenjo/litegraph.js/issues/171
                            nodeEditor.configure(JSON.parse(project.motorGraph));
                            console.log("Loading motor graph.");
                        }
                        else
                        {
                            console.log("No motors found in the project.");
                        }

                        // Motor units 
                        document.getElementById('unit_set').value = project.motorGraphUnits;

                        // TODO: 
                        // Add/load from project: 
                        // - Minimization settings
                        // - NVT settings
                        // - DT
                    }
                    else
                    {
                        console.error("XYZ content not found in the project. Loading aborded.");
                        project.resetProject();
                    }

                }
                reader.readAsText(file);
            }
            else 
            {
                console.warn("No Project file was selected");
            }
        }

        function handleFileSelect(evt) {
            console.log("XYZ File selected: " + evt.target.files[0].name);
            const file = evt.target.files[0];

            if (file) {
                const reader = new FileReader();
                // WTF is this? You have to give a lambda triggered if the load has been successful???
                // HELLOOOOO?
                reader.onload = function(event) {
                    const contents = event.target.result;
                    // Now you can parse the contents of the file
                    // For example, if the file is a JSON, you can parse it as follows:
                    //console.log("File contents:", contents);

                    viewerMolecule.addModel(contents, 'xyz');
                    viewerMolecule.setStyle({}, {stick: {}})
                    viewerMolecule.zoomTo();
                    viewerMolecule.render();

                    //xyzContent = contents;
                    project.setXYZContent(contents, file.name);
                    console.info("Loaded a model from XYZ file with " + viewerMolecule.getModel().getInternalState().atoms.length + " atoms.");

                    $('#info-sim-it').empty();
                    $('#info-sim-it').append('Current Timestep: 0, number of Frames: ' + viewerMolecule.getModel().getNumFrames());

                    // Saving the first frame 
                    // Saving both the positions and original state separatly because the state does contain all the atom informations
                    // which is used in some places 
                    originalState = structuredClone(viewerMolecule.getModel().getInternalState());
                    originalPositions = radahnProjectUtils.viewerToArray(viewerMolecule, 0);
                    // Saving the atom spec which will be used when adding frames to the trajectory

                }
                reader.readAsText(file);
            }
            else 
            {
                console.warn("No XYZ file was selected");
            }
        }

        // Function to create and update the dynamic table
        function updateDynamicTable() {
            const tableContainer = document.getElementById('dynamic-table-container');
            tableContainer.innerHTML = ''; // Clear previous content

            // Create a table element
            const table = document.createElement('table');
            table.className = 'dynamic-table';
            table.setAttribute('border', '1');

            // Create table header
            const headerRow = table.insertRow();
            const headers = ['Name', 'Number of Atoms', 'Color', 'Edit', 'Delete'];
            headers.forEach(headerText => {
                const header = document.createElement('th');
                header.textContent = headerText;
                headerRow.appendChild(header);
            });

            // Populate the table with saved selections
            Object.entries(project.selectionList).forEach(([name, entry]) => {    
                const row = table.insertRow();
                const cellName = row.insertCell();
                cellName.textContent = name;

                const cellNumAtoms = row.insertCell();
                cellNumAtoms.textContent = entry.atomIndexes.length;

                // You can customize the color representation based on the selection
                const cellColor = row.insertCell();
                //cellColor.textContent = 'PLACEHOLDER';_
                const colorInput = document.createElement('input');
                colorInput.type = 'color';
                colorInput.value = entry.color;
                colorInput.disabled = true;
                cellColor.appendChild(colorInput);

                // Add Edit and Delete buttons
                const cellEdit = row.insertCell();
                const editButton = document.createElement('button');
                editButton.textContent = 'Edit';
                editButton.addEventListener('click', () => {
                    // Load the selection into the form
                    document.getElementById('save-selection').value = name;
                    document.getElementById('selection-color').value = entry.color;
                    let strSelection = "";
                    for(let i = 0; i < entry.atomIndexes.length; i++)
                    {
                        strSelection += entry.atomIndexes[i] + " ";
                    }
                    document.getElementById('current-selection').value = strSelection;
                })
                cellEdit.appendChild(editButton);

                const cellDelete = row.insertCell();
                const deleteButton = document.createElement('button');
                deleteButton.textContent = 'Delete';
                deleteButton.addEventListener('click', () => {
                    project.deleteSelection(name);
                    updateDynamicTable();
                    refreshMolecule();
                })
                cellDelete.appendChild(deleteButton);
            });

            // Append the table to the container
            tableContainer.appendChild(table);

            // Update the list of saved selections in the anchor drop menu
            const anchorSourceSelect = document.getElementById('anchor-source');
            anchorSourceSelect.innerHTML = '';
            const defaultOption = document.createElement('option');
            defaultOption.value = 'current-selection';
            defaultOption.textContent = 'Current selection';
            anchorSourceSelect.appendChild(defaultOption);

            Object.keys(project.selectionList).forEach(name => {
                const option = document.createElement('option');
                option.value = name;
                option.textContent = name;
                anchorSourceSelect.appendChild(option);
            });

            // Update the list of saved selections in the thermostat drop menu
            const thermostatSourceSelect = document.getElementById('thermostat-source');
            thermostatSourceSelect.innerHTML = '';
            const defaultOptionThermostat = document.createElement('option');
            defaultOptionThermostat.value = 'current-selection';
            defaultOptionThermostat.textContent = 'Current selection';
            thermostatSourceSelect.appendChild(defaultOptionThermostat);

            Object.keys(project.thermostatList).forEach(name => {
                const option = document.createElement('option');
                option.value = name;
                option.textContent = name;
                thermostatSourceSelect.appendChild(option);
            });
        }

        // Handle the htlm generation for the anchor table
        function updateAnchorTable()
        {
            const tableContainer = document.getElementById('dynamic-anchor-table-container');
            tableContainer.innerHTML = ''; // Clear previous content

            // Create a table element
            const table = document.createElement('table');
            table.className = 'dynamic-table';
            table.setAttribute('border', '1');

            // Create table header
            const headerRow = table.insertRow();
            const headers = ['Name', 'Number of Atoms', 'Color', 'Delete'];
            headers.forEach(headerText => {
                const header = document.createElement('th');
                header.textContent = headerText;
                headerRow.appendChild(header);
            });

            // Populate the table with saved selections
            Object.entries(project.anchorList).forEach(([name, entry]) => {
                const row = table.insertRow();
                const cellName = row.insertCell();
                cellName.textContent = name;

                const cellNumAtoms = row.insertCell();
                cellNumAtoms.textContent = entry.atomIndexes.length;

                // You can customize the color representation based on the selection
                const cellColor = row.insertCell();
                //cellColor.textContent = 'PLACEHOLDER';
                const colorInput = document.createElement('input');
                colorInput.type = 'color';
                colorInput.value = entry.color;
                colorInput.disabled = true;
                cellColor.appendChild(colorInput);

                // Delete button with action
                const cellDelete = row.insertCell();
                const deleteButton = document.createElement('button');
                deleteButton.textContent = 'Delete';
                deleteButton.addEventListener('click', () => {
                    project.deleteAnchor(name);
                    updateAnchorTable();
                    refreshMolecule();
                })
                cellDelete.appendChild(deleteButton);
            });

            // Append the table to the container
            tableContainer.appendChild(table);
        }

        // Handle the htlm generation for the anchor table
        function updateThermostatTable()
        {
            const tableContainer = document.getElementById('dynamic-thermostat-table-container');
            tableContainer.innerHTML = ''; // Clear previous content

            // Create a table element
            const table = document.createElement('table');
            table.className = 'dynamic-table';
            table.setAttribute('border', '1');

            // Create table header
            const headerRow = table.insertRow();
            const headers = ['Name', 'Number of Atoms', 'Color', 'Edit', 'Delete'];
            headers.forEach(headerText => {
                const header = document.createElement('th');
                header.textContent = headerText;
                headerRow.appendChild(header);
            });

            // Populate the table with saved selections
            Object.entries(project.thermostatList).forEach(([name, entry]) => {
                const row = table.insertRow();
                const cellName = row.insertCell();
                cellName.textContent = name;

                const cellNumAtoms = row.insertCell();
                cellNumAtoms.textContent = entry.atomIndexes.length;

                // You can customize the color representation based on the selection
                const cellColor = row.insertCell();
                //cellColor.textContent = 'PLACEHOLDER';
                const colorInput = document.createElement('input');
                colorInput.type = 'color';
                colorInput.value = entry.color;
                colorInput.disabled = true;
                cellColor.appendChild(colorInput);

                // Edit button with action
                const cellEdit = row.insertCell();
                const editButton = document.createElement('button');
                editButton.textContent = 'Edit';
                editButton.addEventListener('click', () => {
                    // Load the selection into the form
                    document.getElementById('save-thermostat').value = name;
                    document.getElementById('thermostat-color').value = entry.color;
                    let strSelection = "";
                    for(let i = 0; i < entry.atomIndexes.length; i++)
                    {
                        strSelection += entry.atomIndexes[i] + " ";
                    }
                    document.getElementById('current-selection').value = strSelection;
                    document.getElementById('thermostat-start').value = entry.startTemp;
                    document.getElementById('thermostat-end').value = entry.endTemp;
                    document.getElementById('thermostat-damp').value = entry.damp;
                    document.getElementById('thermostat-seed').value = entry.seed;
                })
                cellEdit.appendChild(editButton);

                // Delete button with action
                const cellDelete = row.insertCell();
                const deleteButton = document.createElement('button');
                deleteButton.textContent = 'Delete';
                deleteButton.addEventListener('click', () => {
                    project.deleteThermostat(name);
                    updateThermostatTable();
                    refreshMolecule();
                })
                cellDelete.appendChild(deleteButton);
            });

            // Append the table to the container
            tableContainer.appendChild(table);
        }


        function handleForcefieldFileSelect(evt) {
            console.log("Forcefield File selected: " + evt.target.files[0].name);
            const file = evt.target.files[0];

            if (file) {
                const reader = new FileReader();

                reader.onload = function(event) {
                    const contents = event.target.result;
                    
                    console.info("Forcefield " + file.name + " loaded.");

                    project.setPotential(contents, file.name);
                }
                reader.readAsText(file);
            }
            else 
            {
                console.warn("No forcefield file was selected");
            }
        }

        function updateFrameCounter(){
            //document.getElementById('info-sim-it').innerHTML = 'Current Timestep: ' + viewerMolecule.getFrame() + ', number of Frames: ' + viewerMolecule.getModel().getNumFrames();
            
            document.getElementById('info-sim-it').innerHTML = 'Current Timestep: ' + timestepFrames[viewerMolecule.getFrame()] + ', Current Frame: ' + (viewerMolecule.getFrame()) + ', number of Frames: ' + viewerMolecule.getModel().getNumFrames();
            
            if(!viewerMolecule.isAnimated())
            {
                clearInterval(intervalUpdateID);
                intervalUpdateID = null;
            }
        }

        window.onPlayTrajectory = function() {
            console.log("Starting trajectory playback");
            viewerMolecule.animate({loop: "forward", reps:1});
            viewerMolecule.render();

            // Start an interval to update the frame counter
            intervalUpdateID = setInterval(updateFrameCounter, 100);
        }

        window.onStopTrajectory = function() {
            console.log("Stopping trajectory playback");
            viewerMolecule.stopAnimate();
            viewerMolecule.render();

            updateFrameCounter();
        }

        window.onGoToLastFrame = function() {
            console.log("Going to last frame");
            if(viewerMolecule.isAnimated())
            {
                viewerMolecule.stopAnimate();
            }
            viewerMolecule.setFrame(viewerMolecule.getModel().getNumFrames() - 1);
            viewerMolecule.render();

            updateFrameCounter();
        }

        window.onGoToNextFrame = function() {
            console.log("Going to next frame");
            if(viewerMolecule.isAnimated())
            {
                viewerMolecule.stopAnimate();
            }
            if(viewerMolecule.getFrame() < viewerMolecule.getModel().getNumFrames() - 1)
            {
                viewerMolecule.setFrame(viewerMolecule.getFrame() + 1);
                viewerMolecule.render();
            }
            updateFrameCounter();
        }

        window.onGoToPreviousFrame = function() {
            console.log("Going to previous frame");
            if(viewerMolecule.isAnimated())
            {
                viewerMolecule.stopAnimate();
            }
            if(viewerMolecule.getFrame() > 0)
            {
                viewerMolecule.setFrame(viewerMolecule.getFrame() - 1);
                viewerMolecule.render();
            }
            updateFrameCounter();
        }

        window.onGoToFirstFrame = function() {
            console.log("Going to first frame");
            if(viewerMolecule.isAnimated())
            {
                viewerMolecule.stopAnimate();
            }
            viewerMolecule.setFrame(0);
            viewerMolecule.render();

            updateFrameCounter();
        }

        window.onGoToUserFrame = function() {
            console.log("Going to user frame");
            if(viewerMolecule.isAnimated())
            {
                viewerMolecule.stopAnimate();
            }
            let frame = parseInt(document.getElementById('user-frame').value);
            if(frame >= 0 && frame < viewerMolecule.getModel().getNumFrames())
            {
                viewerMolecule.setFrame(frame);
                viewerMolecule.render();
            }
            else
            {
                console.warn("Invalid trajetory frame number requested: " + frame);
            }
            updateFrameCounter();
        }

        window.updatePlots = function() {
            console.log("Updating plot configuration");
            // Get the current fields selected
            let plot1Field = document.getElementById("select-plot1").value;
            if(plot1Field != "none" && (firstPlotKey === null || firstPlotKey !== plot1Field))
            {
                // Update the plot
                chart1.data.datasets[0].label = plot1Field;
                // Using array reference instead of copy so that we just have to update the kvsData structure
                // when receiving new data
                chart1.data.labels = kvsData[plot1Field].it;
                chart1.data.datasets[0].data = kvsData[plot1Field].values; 
                chart1.update();

                firstPlotKey = plot1Field;
            }
            let plot2Field = document.getElementById("select-plot2").value;
            if(plot2Field != "none" && (secondPlotKey === null || secondPlotKey !== plot2Field))
            {
                // Update the plot
                chart2.data.datasets[0].label = plot2Field;
                // Using array reference instead of copy so that we just have to update the kvsData structure
                // when receiving new data
                chart2.data.labels = kvsData[plot2Field].it;
                chart2.data.datasets[0].data = kvsData[plot2Field].values; 
                chart2.update();

                secondPlotKey = plot2Field;
            }
        }

        // Make the function global so that it's accessible to the "save" button
        window.saveSelectionInternal = function() {
            if (selectedAtoms.length > 0 && document.getElementById('save-selection').value.length > 0) {
                if(!document.getElementById('save-selection').checkValidity())
                {
                    console.error("Invalid selection name. The selection name can only be alphanumerical [A-Za-z0-9].");
                    return;
                }
                let selectionName = document.getElementById('save-selection').value;
                let selectionDict = {
                    atomIndexes: selectedAtoms.slice(), 
                    name: document.getElementById('save-selection').value,
                    color: document.getElementById('selection-color').value
                };

                project.addSelection(selectionName, selectionDict);
                console.log("Added the selection " + document.getElementById('save-selection').value);

                // Update the table
                updateDynamicTable();
            }
            else 
            {
                console.log("No selection was selected or a name was not given")
            }
        }

        window.saveAnchor = function() {
            // Get the name of the anchor
            let anchorName = document.getElementById('save-anchor').value;
            if(anchorName.length == 0)
            {
                console.warn("No name was given for the anchor");
                return;
            }

            if(!document.getElementById('save-anchor').checkValidity())
            {
                console.error("Invalid anchor name. The anchor name can only be alphanumerical [A-Za-z0-9].");
                return;
            }

            // Get the name of the selection associated with the anchor
            let selectionName = document.getElementById('anchor-source').value;
            if(selectionName === "current-selection")
            {
                if(selectedAtoms.length > 0)
                {
                    // Using the current selection for the new anchor
                    let anchorDict = {
                        name: anchorName,
                        color: document.getElementById('anchor-color').value,
                        atomIndexes: selectedAtoms.slice()
                    };

                    project.addAnchor(anchorName, anchorDict);
                    console.log("Added the anchor " + anchorName);

                    // Update the table
                    updateAnchorTable();
                }
            }
            else if(selectionName in project.selectionList)
            {
                let anchorDict = {
                        name: anchorName,
                        color: document.getElementById('anchor-color').value,
                        atomIndexes: project.selectionList[selectionName].atomIndexes.slice()
                    };

                project.addAnchor(anchorName, anchorDict);
                console.log("Added the anchor " + anchorName);

                // Update the table
                updateAnchorTable(); 
            }
            else 
            {
                console.warn("The selection " + selectionName + " does not exist");
            }

            return;
        }

        window.saveThermostat = function() {
            // Get the name of the anchor
            let thermostatName = document.getElementById('save-thermostat').value;
            if(thermostatName.length == 0)
            {
                console.warn("No name was given for the thermostat");
                return;
            }

            if(!document.getElementById('save-thermostat').checkValidity())
            {
                console.error("Invalid thermostat name. The thermostat name can only be alphanumerical [A-Za-z0-9].");
                return;
            }

            // Get the name of the selection associated with the anchor
            let selectionName = document.getElementById('thermostat-source').value;
            let selectionIndices = [];
            if(selectionName === "current-selection")
            {
                if(selectedAtoms.length > 0)
                {
                    selectionIndices = selectedAtoms.slice();
                }
                else
                {
                    console.warn("No atoms are selected to create a thermostat.");
                    return;
                }
            }
            else if(selectionName in project.selectionList)
            {
                selectionIndices = project.selectionList[selectionName].atomIndexes.slice();
            }
            else 
            {
                console.warn("The selection " + selectionName + " does not exist");
                return;
            }

            let thermostatColor = document.getElementById('thermostat-color').value;
            let thermostatStartTemp = parseFloat(document.getElementById('thermostat-start').value);
            let thermostatEndTemp = parseFloat(document.getElementById('thermostat-end').value);
            let thermostatDamp = parseFloat(document.getElementById('thermostat-damp').value);
            let thermostatSeed = parseInt(document.getElementById('thermostat-seed').value);

            project.addThermostat(thermostatName, {
                name: thermostatName,
                color: thermostatColor,
                atomIndexes: selectionIndices,
                startTemp: thermostatStartTemp,
                endTemp: thermostatEndTemp,
                damp: thermostatDamp,
                seed: thermostatSeed
            });

            updateThermostatTable();

            return;
        }

        window.refreshMolecule = function() {
            //console.log("Refreshing the molecule");
            let vizStyle = document.getElementById("color-by").value;

            //<option value="atom-type">Atom Type</option>
            //<option value="selection">Selection</option>
            switch(vizStyle) {
                case "atom-type": {
                    viewerMolecule.setStyle({}, {stick: {}})
                    break;
                }
                case "selection": {
                    // We first color by atom type for every atoms, then we re-color by selection
                    viewerMolecule.setStyle({}, {stick: {}})
                    Object.entries(project.selectionList).forEach(([name, entry]) => {
                        viewerMolecule.getModel().setStyle({'serial': entry.atomIndexes}, {'stick': {'color': entry.color}});
                    });
                    break;
                }
                case "anchor": {
                    // We first color by atom type for every atoms, then we re-color by anchor
                    viewerMolecule.setStyle({}, {stick: {}})
                    Object.entries(project.anchorList).forEach(([name, entry]) => {
                        viewerMolecule.getModel().setStyle({'serial': entry.atomIndexes}, {'stick': {'color': entry.color}});
                    });
                    break;
                }
                case "thermostat": {
                    // We first color by atom type for every atoms, then we re-color by thermostat
                    viewerMolecule.setStyle({}, {stick: {}})
                    Object.entries(project.thermostatList).forEach(([name, entry]) => {
                        viewerMolecule.getModel().setStyle({'serial': entry.atomIndexes}, {'stick': {'color': entry.color}});
                    });
                    break;
                }
                case "jigs": {
                    // We go through every type of jigs in order

                    // First is default refresentation
                    viewerMolecule.setStyle({}, {stick: {}})

                    // Second is the selection, i.e least prioritized
                    Object.entries(project.selectionList).forEach(([name, entry]) => {
                        viewerMolecule.getModel().setStyle({'serial': entry.atomIndexes}, {'stick': {'color': entry.color}});
                    });

                    // Third are anchor and thermostat. Technically putting thermostat third because in case of overlap, the anchor would be applied
                    Object.entries(project.thermostatList).forEach(([name, entry]) => {
                        viewerMolecule.getModel().setStyle({'serial': entry.atomIndexes}, {'stick': {'color': entry.color}});
                    });

                    Object.entries(project.anchorList).forEach(([name, entry]) => {
                        viewerMolecule.getModel().setStyle({'serial': entry.atomIndexes}, {'stick': {'color': entry.color}});
                    });
                    break;
                }
                default: {
                    viewerMolecule.setStyle({}, {stick: {}})
                    break;
                }
            }

            
            let labelType = document.getElementById("atom-label").value;
            if(labelType != currentLabelsType) {
                //<option value="none">None</option>
                //<option value="index">Index</option>

                // Remove the previous labels
                if(currentLabels.length > 0) {
                    for(let i = 0; i < currentLabels.length; i++) {
                        viewerMolecule.removeLabel(currentLabels[i]);
                    }
                    currentLabels = [];
                }

                // Process the new labels
                currentLabelsType = labelType;
                switch(labelType) {
                    case "none": {
                        // Nothing to do
                        break;
                    }
                    case "index": {
                        let atoms = viewerMolecule.getModel().getInternalState().atoms;
                        if(atoms.length > 0)
                        {
                            for(let i = 0; i < atoms.length; i++)
                            {
                                currentLabels.push(viewerMolecule.addLabel(""+atoms[i].index, {frontsize: 11.5, inFront:true, position: atoms[i], opacity: 0.5}));
                            }
                        }
                        break;
                    }
                    default: {
                        // Nothing to do
                        break;
                    }
                }
            }
            
            
            viewerMolecule.render();
        }

        // Method to generate the file and download it
        // Alternative to onSaveProjectSetupServer()
        // https://stackoverflow.com/questions/11071473/how-can-javascript-save-to-a-local-file
        // https://jsfiddle.net/9av2mfjx/
 
        var a = $('a');
        window.onSaveProjectSetupDownload = function() {
            // We want to save: 
            // - project name                       (need to update)
            // - original positions (xyz content)   (already in the project)
            // - potential file                     (already in the project)
            // - motor graph state                  (need to update)
            // - unit style used for the motor      (need to update)
            // - list of anchors                    (already in the project)
            // - list of selections                 (already in the project)
            // - NVT setup                          (need to update)

            let projectName = document.getElementById('project-name').value;
            if(projectName.length == 0)
            {
                console.error("Project name cannot be empty.");
                return;
            }
            project.setProjectName(projectName)

            if(!project.isXYZSet())
            {
                console.error("XYZ not set yet, unable to save the project.");
                return;
            }

            // Update the project motor graph and unit
            project.setMotorGraph(JSON.stringify(nodeEditor.serialize()), document.getElementById("unit_set").value);

            // Update the NVT section
            refreshMinimizeSetup();

            // Update the NVT section
            refreshNVTSetup();

            // All the updates are done, now we can get the project to save it

            // Get the project on its dictionary form so it can be sent
            let projectContent = project.createProjectDict();

            // Save the file 
            //console.log(projectContent);
            let fileContent = JSON.stringify(projectContent);
            var bb = new Blob([fileContent], {type: 'text/plain'});
            var a = document.createElement('a');
            //let filename = 
            a.download = 'project.json';
            a.href = window.URL.createObjectURL(bb);
            a.style='display:none';
            a.click();
            a.remove();

            console.log("Link generated to save the project.");
        }

        // Method forwarding the content to the server to save it
        window.onSaveProjectSetupServer = function() {
            // We want to save: 
            // - project name                       (need to update)
            // - original positions (xyz content)   (already in the project)
            // - potential file                     (already in the project)
            // - motor graph state                  (need to update)
            // - unit style used for the motor      (need to update)
            // - list of anchors                    (already in the project)
            // - list of selections                 (already in the project)
            // - NVT setup                          (need to update)

            let projectName = document.getElementById('project-name').value;
            if(projectName.length == 0)
            {
                console.error("Project name cannot be empty.");
                return;
            }
            project.setProjectName(projectName)

            if(!project.isXYZSet())
            {
                console.error("XYZ not set yet, unable to save the project.");
                return;
            }

            // Update the project motor graph and unit
            project.setMotorGraph(JSON.stringify(nodeEditor.serialize()), document.getElementById("unit_set").value);

            // Update the minimize section
            refreshMinimizeSetup();

            // Update the NVT section
            refreshNVTSetup();

            // All the updates are done, now we can get the project to save it

            // Get the project on its dictionary form so it can be sent
            let projectContent = project.createProjectDict();

            //let fileContent = JSON.stringify(projectContent);
            socket.emit('save_project', projectContent);
            console.log("Project content sent to the server.");
        }

        window.downloadJobFolder = function() {
            const jobFolderPath = document.getElementById("job_folder").value;
            if(jobFolderPath.length == 0)
            {
                console.error("Job folder path currently empty.");
                return;
            }

            const jobFolder = jobFolderPath.split("/").pop();

            window.location.href = '/download_job_folder?job_folder=' + jobFolder;
            console.log("DownloadJobFolder was called to download the job " + jobFolder);
        }
    });
    </script>
    <style>
        body {
            width: 100vw;
            height: 100vh;
            margin: 0;
            overflow: hidden;
            font-size: small;
        }
        .left {
            float: left;
            width: 30%;
            margin: 10px;
        }
        .middle {
            float: left;
            width: 33%;
            height: 100%;
            margin: 10px;
        }
        .right {
            float: left;
            width: 33%;
            
        }

        #wrapper {
            position: relative;
        }

        #visualization {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 0; /* Ensure it's above visualization-overlay */
            width: 90%;
            height: 400px;
        }

        #visualization-overlay {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1; /* Ensure it's below visualization */
            width: 90%;
            height: 400px;
            /*background-color: rgba(196, 39, 135, 1); */
            background-color: rgba(0, 0, 0, 0);
        }

        #info {
            position: relative;
            top: 450px;
            left: 0;
        }

        #current-selection-container {
            width: 90%;
            margin-bottom: 5px;
            margin-top: 5px;
            display: table;
        }

        #current-selection-label {
            display: table-cell;
            width: 1px;
            white-space: nowrap;
        }
        #current-selection {
            width: 90%;
        }

        #current-selection-span {
            display: table-cell;
        }

        #node-canvas {
            width: 100%;
            height: 50%;
            border: 1px solid;
        }

        #log-container { overflow: auto; height: 300px; }

        #span_job_folder { display: block; overflow: hidden; padding-right: 10px;}
        #job_folder { width: 60%; }

        .log-warn { color: orange }
        .log-error { color: red }
        .log-info { color: skyblue }
        .log-log { color: black }

        .log-warn, .log-error { font-weight: bold; }
    </style>
    <div class="left">
        <h1>Radahn Mega Frontend</h1>

        <h2>Project</h2>
        <div>
            <div>
                <label for="project-file">Open Project:</label>
                <input type="file" id="project-file" accept=".json">
            </div>
            <div>
                <label for="project-name">Project name:</label>
                <input type="text" id="project-name" pattern="[A-Za-z0-9]{1,}">
            </div>
            <button onclick="onSaveProjectSetupServer()" name="Save Project">Save Project</button>
            <button onclick="onSaveProjectSetupDownload()" name="Download Project">Download Project</button>
            <a href="" style="display: none;"></a>
        </div>
        
        <h2>Model Import</h2>
        <div>
            <label for="xyz-file">Select XYZ file:</label>
            <input type="file" id="xyz-file" accept=".xyz">
        </div>
        
        <h2>Radahn Setup</h2>
        <div>
            <fieldset>
                <legend>General settings</legend>
                <div>
                    <label for="ff-file">Select Potential file:</label>
                    <input type="file" id="ff-file" accept=".reax,.rebo,.airebo,.airebo-m">
                </div>
                <div>
                    <label>Settings Unit Set:</label>
                    <select id="unit_set">
                        <option name="LAMMPS_METAL" value="LAMMPS_METAL">Metal</option>
                        <option name="LAMMPS_REAL" value="LAMMPS_REAL">Real</option>
                    </select>
                </div>
                <div>
                    <label for="dt_input">dt (Time unit):</label>
                    <input type="number" id="dt_input" name="dt_input" value="0.5">
                </div>
                <div>
                    <label>Number of cores:</label>
                    <input type="number" id="num_cores" name="num_cores" value="1"></input>
                </div>
                <div>
                    <label>Update frequency:</label>
                    <input type="number" id="update_frequency" name="update_frequency" value="100"></input>
                </div>
            </fieldset>
        </div>
        <div>
            <fieldset>
                <legend>Minimization</legend>
                <div>
                    <input type="radio" id="no_minimization" name="mingroup" value="nomin">
                    <label for="no_minimization">No minimization</label>
                </div>
                <div>
                    <input type="radio" id="minimization" name="mingroup" value="min" checked>
                    <label for="minimization">Regular minimization</label>
                </div>
                <div>
                    <input type="radio" id="deep_minimization" name="mingroup" value="deepmin">
                    <label for="deep_minimization">Deep minimization</label>
                </div>
            </fieldset>
        </div>
        <div>
            <fieldset>
                <legend>Thermalization</legend>
                <div>
                    <input type="radio" id="no_thermalisation" name="nvtgroup" value="nonvt" checked>
                    <label for="no_thermalisation">No thermalization</label>
                </div>
                <div>
                    <input type="radio" id="createvel" name="nvtgroup" value="createvelocity">
                    <label for="createvel">Create velocities:</label>
                    <fieldset>
                        <label for="create_vel_temp">Temperature:</label>
                        <input type="number" id="create_vel_temp" value="0.01">
                        <label for="create_vel_seed">Seed:</label>
                        <input type="number" id="create_vel_seed" value="1234">
                    </fieldset>
                </div>
                <!--label for="enablenvt">Enable NVT phase:</label>
                <input type="checkbox" id="enablenvt" name="enablenvt" onchange="form.nvtfields.disabled= !checked" checked-->
                <div name="nvtfields">
                    <!--legend>NVT</legend-->
                    <input type="radio" id="nvtphase" name="nvtgroup" value="nvtphase">
                    <label for="nvtphase">NVT phase</label>
                    <fieldset>
                        <label for="nvtsteps">NVT steps:</label>
                        <input type="number" id="nvtsteps" name="nvtsteps">
                        <label for="startTemp">Start temperature:</label>
                        <input type="number" id="startTemp" name="startTemp">
                        <label for="endTemp">End temperature:</label>
                        <input type="number" id="endTemp" name="endTemp">
                        <label for="damp">Damp:</label>
                        <input type="number" id="damp" name="damp">
                        <label for="seed">Seed:</label>
                        <input type="number" id="seed" name="seed">
                    </fieldset>
                </div>
            </fieldset>
        </div>
        <div>
            <fieldset>
                <legend>NVE</legend>
                <div>
                    <label>Maximum number of timesteps:</label>
                    <input type="number" id="num_timesteps" name="num_timesteps" value="10000"></input>
                </div>
                <div>
                    <label for="force_max_steps">Force maximum number of steps:</label>
                    <input type="checkbox" id="force_max_steps" name="force_max_steps" value="true"></input>
                </div>
            </fieldset>
        </div>
        <h2>Simulation Operation</h2>
        <!--div>
            <form id="start_listening" method="POST" action="#">
                <input type="submit" value="Start listening">
            </form>
        </div-->
        <div>
            <label>Start from:</label>
            <select id="start_from" name="start_from">
                <option value="original">Original File</option>
                <option value="current-frame">Current Frame</option>
            </select>
            <!--form id="generate_inputs" method="POST" action="#">
                <input type="submit" value="Generate inputs"></input>
            </form-->
            <button id="generate_inputs" onclick="generate_inputs()">Generate Inputs</button>
            <!--form id="launch_simulation" method="POST" action="#">
                <input type="submit" value="Launch"></input>
            </form-->
            <button id="launch_simulation" onclick="launch_simulation()">Launch Simulation</button>
        </div>
        <!--div>
            <form id="print_motors" method="POST" action="#">
                <input type="submit" value="Print motors">
            </form>
        </div-->
        <div>
            <span id="span_job_folder">
            <label>Job Folder: </label>
            <input type="text" id="job_folder" name="job_folder" value="" readonly></input>
            <!--form id="open_job_folder" method="POST" action="#">
                <input type="submit" value="Open"></input>
            </form-->
            <button id="open_job_folder" onclick="open_job_folder()">Open Job Folder</button>
            <button id="download_job_folder" onclick="downloadJobFolder()">Download Job Folder</button>
            </span>
        </div>
        <h2>Log Console</h2>
        <div id="log-container">
            <pre id="log"></pre>
          </div>
    </div>
    <div class="middle">
        <h2>Plots</h2>
        <label>Plots 1:</label>
        <select id="select-plot1">
            <option value="none">None</option>
        </select>
        <label>Plots 2:</label>
        <select id="select-plot2">
            <option value="none">None</option>
        </select>
        <button id="updatePlots" onclick="updatePlots()">Update Plots</button>

        <div id="plot_section">
        <canvas id="plot-canvas"></canvas>
        </div>
        <div id="sep canvas">
        <canvas id="plot-canvas-temp"></canvas>
        </div>
        <h2>Motor Graph</h2>
        <div id="node_section">
            <canvas id="node-canvas"></canvas>
            <!--canvas id="node-canvas" width = "1080" height = "720" style="border: 1px solid"></canvas-->
        </div>
    </div>
    <div class="right">
        <h2>Visualization:</h2>
        <div id="wrapper">  
            <div id="visualization" class="mol-container"></div>
            <canvas id="visualization-overlay" class="mol-overlay"></canvas>
            <div id="info">
                <fieldset>
                    <legend>Viewer</legend>
                    <label>Color by:</label>
                    <select id="color-by">
                        <option value="atom-type">Atom Type</option>
                        <option value="selection">Selection</option>
                        <option value="anchor">Anchor</option>
                        <option value="thermostat">Thermostat</option>
                        <option value="jigs">Jigs</option>
                    </select>
                    <label>Label:</label>
                    <select id="atom-label">
                        <option value="none">None</option>
                        <option value="index">Index</option>
                    </select>
                    <button id="toggle-atom-colors" onclick="refreshMolecule()">Update</button>
                    <p id="info-sim-it">Current Timestep: 0</p>
                    <p>
                        <button id="play-button" onclick="onPlayTrajectory()">Play</button>
                        <button id="stop-button" onclick="onStopTrajectory()">Stop</button>
                        <button id="next-button" onclick="onGoToNextFrame()">Next</button>
                        <button id="prev-button" onclick="onGoToPreviousFrame()">Prev</button>
                        <button id="first-button" onclick="onGoToFirstFrame()">First</button>
                        <button id="last-button" onclick="onGoToLastFrame()">Last</button>
                        <button id="reset-button" onclick="onGoToUserFrame()">Go to</button>
                        <input type="number" id="user-frame" name="user-frame"></input>
                    </p>
                </fieldset>
                <fieldset>
                    <legend>Selections</legend>
                    <div id="current-selection-container">
                        <label id="current-selection-label">Current Selection: </label>
                        <span id="current-selection-span"><input type="text" id="current-selection" name="current-selection"></input></span>
                    </div>
                    <div>
                        <label for="save-selection">Selection name:</label>
                        <input type="text" id="save-selection" name="save-selection" pattern="[A-Za-z0-9]{1,}"></input>
                        <input type="color" id="selection-color" name="selection-color"></input>
                        <button id="save-selection-button" onclick="saveSelectionInternal()">Save</button>
                    </div>
                    <div id="dynamic-table-container"></div>
                </fieldset>
                <fieldset>
                    <legend>Anchors</legend>
                    <label for="save-anchor">Anchor name:</label>
                    <input type="text" id="save-anchor" name="save-anchor" pattern="[A-Za-z0-9]{1,}"></input>
                    <input type="color" id="anchor-color" name="anchor-color"></input>
                    <select id="anchor-source">
                        <option value="current-selection">Current selection</option>
                    </select>
                    <button id="save-anchor-button" onclick="saveAnchor()">Save</button>
                    <div id="dynamic-anchor-table-container"></div>
                </fieldset>
                <fieldset>
                    <legend>Thermostats</legend>
                    <div>
                        <label for="save-thermostat">Thermostat name:</label>
                        <input type="text" id="save-thermostat" name="save-thermostat" pattern="[A-Za-z0-9]{1,}"></input>
                        <label for="thermostat-color">Color:</label>
                        <input type="color" id="thermostat-color" name="thermostat-color"></input>
                        <select id="thermostat-source">
                            <option value="current-selection">Current selection</option>
                        </select>
                        <br>
                        <label for="thermostat-start">Start Temp (K):</label>
                        <input type="number" id="thermostat-start" name="thermostat-start"></input>
                        <label for="thermostat-end">End Temp (K):</label>
                        <input type="number" id="thermostat-end" name="thermostat-end"></input>
                        <label for="thermostat-damp">Damp (Time unit):</label>
                        <input type="number" id="thermostat-damp" name="thermostat-damp"></input>
                        <label for="thermostat-seed">Seed:</label>
                        <input type="number" id="thermostat-seed" name="thermostat-seed"></input>
                        <button id="save-thermostat-button" onclick="saveThermostat()">Save</button>
                    </div>
                    <div id="dynamic-thermostat-table-container"></div>
                </fieldset>
            </div>
        </div>
        
    </div>
</body>
</html>
