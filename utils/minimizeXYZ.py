from ase.io import write, read
from ase.atoms import Atoms
import subprocess

from pathlib import Path

import os
import numpy as np
import argparse

def getElementsFromData(dataPath: str) -> str:
    """Get elements from data file

    Args:
        data_file: LAMMPS data file

    Returns:
        elements: LAMMPS atom types

    """
    with open(dataPath, 'r') as f:
        lines = f.readlines()
    i = 0
    for line in lines:
        if line[:6] == 'Masses':
            ini = i + 2
        if line[:5] == 'Atoms':
            fin = i - 1
        i += 1
    elements = ''
    for line in lines[ini:fin]:
        elements += ' ' + line.split()[-1]
    return elements

def xyzToLammpsDataPBC(xyzPath:str, dataPath:str) -> Atoms:
    """Convert xyz to LAMMPS data

    Args:
        xyz_file: XYZ file

    Returns:
        data_file: LAMMPS data file

    """
    atoms = read(xyzPath)

    if atoms.get_cell().max() == 0:
        if os.path.isfile('cell.txt'):
            cell = np.loadtxt('cell.txt')
        else:
            cell = [500, 500, 500]
        atoms.set_cell([cell[0], cell[1], cell[2]])
    if atoms.get_positions().min() < 0:
        atoms.center()
    write(filename=dataPath, images=atoms, format='lammps-data', atom_style='full')

    chemical_symbols = atoms.get_chemical_symbols()
    masses = atoms.get_masses()
    indexes = np.unique(chemical_symbols, return_index=True)[1]
    masses_u = [masses[index] for index in indexes]
    chemical_symbols_u = [chemical_symbols[index] for index in indexes]

    with open(dataPath, 'r') as f:
        lines = f.readlines()

    with open(dataPath, 'w') as f:
        f.write('# Generated by Radahn\n')
        for i in range(2,7):
            f.write(lines[i])
        f.write('\n')
        f.write('Masses\n')
        f.write('\n')
        for i in range(len(masses_u)):
            f.write(f'{i + 1} {masses_u[i]} # {chemical_symbols_u[i]}\n')
        f.write('\n')
        f.write('Atoms # full\n')
        f.write('\n')
        for i in range(11, len(lines)):
            f.write(lines[i])
    
    return atoms

def generate_inputs(xyzFile:Path, ffFile:Path) -> None:

    dataFile = "input.data"

    # Generate the base Lammps script
    lammpsScriptFile = "input.lammps"
    useAcks2 = False
    elements = ""
    with open(lammpsScriptFile, "w") as f:
        # Convert the XYZ to a .data file 
        atoms = xyzToLammpsDataPBC(xyzFile, dataFile)

        # Extract the simulation box
        cell = atoms.get_cell()
        minCellDim = min([cell[0][0], cell[1][1], cell[2][2]])
        #print(f"Minimum cell dimension: {minCellDim}")

        # Get back the list of elements
        elements = getElementsFromData(dataFile)

        scriptContent = "# -*- mode: lammps -*-\n"
        scriptContent += 'units          real\n'
        scriptContent += 'atom_style     full\n'
        scriptContent += 'atom_modify    map hash\n'
        scriptContent += 'newton         on\n'
        scriptContent += 'boundary       p p p\n'

        scriptContent += 'read_data      input.data\n'
        #for i in range(len(indexes)):
        #    scriptContent += f'mass           {i + 1} {masses_u[i]}\n' 
        scriptContent += 'pair_style     reaxff NULL mincap 1000\n'
        scriptContent += f'pair_coeff     * * {ffFile.name}{elements}\n'
        if useAcks2:
            scriptContent += 'fix            ReaxFFSpec all acks2/reaxff 1 0.0 10.0 1e-8 reaxff\n'
        else:
            scriptContent += 'fix            ReaxFFSpec all qeq/reaxff 1 0.0 10.0 1e-8 reaxff\n'
        #scriptContent += 'neighbor       2.5 bin\n' 
        # 2.5 is too large for small molecule like benzene. Trying to compute a reasonable cell skin based on the simulation box
        scriptContent += f"neighbor       {min([2.5, minCellDim/2])} bin\n"
        scriptContent += 'neigh_modify   every 1 delay 0 check yes\n'


        # Add basic IO setup
        scriptContent += """####

thermo         50
thermo_style   custom step etotal pe ke temp press pxx pyy pzz lx ly lz
thermo_modify  flush yes lost warn

dump           dump all custom 100 fulltrajectory.dump id type x y z q
dump_modify    dump sort id
dump           xyz all xyz 100 fulltrajectory.xyz
dump_modify    xyz sort id element C H
fix            fixbond all reaxff/bonds 100 bonds_reax.txt

####

timestep       0.5"""
        scriptContent += "\n\n"

        # Minimize section
        scriptContent += "min_style      cg\n"
        scriptContent += 'minimize       0.0001 10e-5 100 10000\n'

        # Save the state in xyz format
        scriptContent += 'write_restart  trajectory.restart\n'
        #scriptContent += 'write_data     minimized_state.xyz\n'
        scriptContent += 'dump dumpID all xyz 1 minimized_state.xyz\n'
        scriptContent += 'run 0\n'


        f.write(scriptContent)

    # Generate the data file
    dataFile = "input.data"
    xyzToLammpsDataPBC(xyzFile, dataFile)


    # Execute the LAMMPS script
    subprocess.run(["mpirun", "-np", "1", "/home/matthieu/dev/lammps/lammps-17Apr2024/build/install/bin/lmp", "-in", "input.lammps"])


    # Update the XYZ file to have elements intead of particle types
    minimizeXYZFile = Path("minimized_state.xyz")
    if not minimizeXYZFile.is_file():
        raise FileNotFoundError(f"Could not find the minimized state {minimizeXYZFile} to update the XYZ file with elements.")

    correctedXYZFile = Path("minimized_state_corrected.xyz")
    with open(minimizeXYZFile, "r") as f:
        lines = f.readlines()
    
    typeToElement = {}
    elementsSplit = elements.split()
    print(elementsSplit)
    for i, elem in enumerate(elementsSplit):
        typeToElement[str(i + 1)] = elem
    print("Type to Element table:")
    print(typeToElement)

    with open(correctedXYZFile, "w") as f:
        f.write(lines[0])
        f.write(lines[1])
        for i, line in enumerate(lines[2:]): # first 2 lines are comments
            properties = line.split()
            if properties[0] not in typeToElement:
                raise ValueError(f"Element {properties[0]} not found in the LAMMPS data file.")
            properties[0] = typeToElement[properties[0]]
            f.write(" ".join(properties))
            if i < len(lines) - 2:
                f.write("\n")

    return 

def main():
    parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument("--xyz",
                        help = "Path to the xyz file to minimize.",
                        dest = "xyz",
                        required = True)
    parser.add_argument("--potential",
                        help = "Lammps potential file.",
                        dest = "potential",
                        required = True)
    
    args = parser.parse_args()

    potentialFile = Path(args.potential)
    if not potentialFile.is_file():
        raise FileNotFoundError(f"The potential file {potentialFile} requested by the user does not exist.")
    
    XYZFile = Path(args.xyz)
    if not XYZFile.is_file():
        raise FileNotFoundError(f"The XYZ file {XYZFile} requested by the user does not exist.")
    

    generate_inputs(XYZFile, potentialFile)
    


if __name__ == "__main__":
    main()